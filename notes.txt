phase 1: 6520e30

1. uv init
2. uv venv

uv add flask
create /app
create /app/main.py (hello, world flask == main route)
create Dockerfile


docker build -t resume-agent-app .
docker run -p 8080:8080 resume-agent-app


phase 2: 
1. uv add psycopg2-binary python-dotenv
2. create .env with DB stuff
3. create docker-compose.yml

docker volume ls
docker volume inspect postgres_data

When the left side of the volumes: entry isn’t a local path (e.g., . or ./data), Docker treats it as a named volume and automatically creates it under its own storage directory.

So:

Syntax	Type	Where it lives
.:/app	Bind mount	Your local filesystem
./data:/var/lib/postgresql/data	Bind mount	Your local ./data folder
postgres_data:/var/lib/postgresql/data	Named volume	Docker-managed, not visible locally

In short:

No local path on the left side → Docker-managed volume.



in init db we use the same dockerfile as the app. 
In Docker, ENTRYPOINT overrides CMD (or more precisely, it replaces the default command that would otherwise run when the container starts).


docker compose up --build



phase 3
1. npm create vue@latest frontend
only select vue router, ESLint and Prettier. also include example starter code.

src/App.vue
<template>
  <div id="app">
    <router-view />
  </div>
</template>

<script setup>
// Empty for now
</script>

<style>
#app {
  font-family: sans-serif;
  text-align: center;
  margin-top: 2rem;
}
</style>


src/views/HomeView.vue
<template>
  <div>
    <h1>Hello from Vue + Flask!</h1>
    <p>This will soon connect to your Flask backend.</p>
  </div>
</template>

delete:
src/components/
src/assets/logo.svg
src/assets/main.css

add to docker compose
  frontend:
    container_name: resume-agent-frontend
    build:
      context: ./frontend
      dockerfile: Dockerfile
    ports:
      - "5173:5173"
    volumes:
      - ./frontend:/app
    environment:
      - VITE_API_BASE=http://flask-app:8080/api
    depends_on:
      - flask-app

In frontend/vite.config.js connects vue to the flask backend:
export default defineConfig({
  server: {
    host: true,
    port: 5173,
    proxy: {
      '/api': {
        target: 'http://flask-app:8080',
        changeOrigin: true,
        secure: false,
      },
    },
  },
});

Now any fetch("/api/...") in Vue will reach your Flask app.


- /app/node_modules
That tells Docker:

“Mount my project files from the host, but keep node_modules inside the container.”

Without that, the bind mount ./frontend:/app hides the installed dependencies.




final phase:
assign token count limit for each user.
